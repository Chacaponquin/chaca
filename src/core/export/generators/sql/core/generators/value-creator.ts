import { ChacaError } from "../../../../../../errors";
import { ChacaUtils } from "../../../../../utils";
import { Datatype } from "../../../../core/datatype";
import { SkipInvalid } from "../../../../core/skip-invalid";
import { GenerateIds } from "../../value-object/generate-ids";
import {
  SQLFloat,
  SQLInteger,
  SQLBigint,
  SQLBoolean,
  SQLDate,
  SQLNull,
  SQLText,
  SQLVarchar,
  SQLDatatype,
} from "../sql-types";
import { SQLColumn } from "../table/column";
import { SQLRow } from "../table/row";
import { RowColumn } from "../table/row-column";
import { SQLTable } from "../table/table";
import { SQLTables } from "../table/tables";
import { FillParentKeys } from "./fill-parent-keys";
import { TablesFixer } from "./fixer";
import { ColumnName, TableName } from "./names";
import { Route } from "./route";

interface Props {
  route: Route;
  value: any;
  parent: SQLTable;
  current: { row: SQLRow } | null;
  nested: boolean;
}

export class ValueCreator {
  constructor(
    private readonly utils: ChacaUtils,
    private readonly fixer: TablesFixer,
    private readonly tables: SQLTables,
    private readonly skipInvalid: SkipInvalid,
    private readonly generateIds: GenerateIds,
    private readonly fillParentKeys: FillParentKeys,
  ) {}

  execute({
    route,
    value,
    current,
    parent,
    nested,
  }: Props): SQLDatatype | null {
    const type = Datatype.filter<SQLDatatype | null>(value, {
      int(value) {
        return new SQLInteger(value);
      },
      float(value) {
        return new SQLFloat(value);
      },
      bigint(value) {
        return new SQLBigint(value);
      },
      boolean(value) {
        return new SQLBoolean(value);
      },
      date(value) {
        return new SQLDate(value);
      },
      function: () => {
        if (!this.skipInvalid.value()) {
          throw new ChacaError(
            `You can not export a function into a sql file.`,
          );
        }

        return null;
      },
      null() {
        return new SQLNull();
      },
      nan(value) {
        return new SQLFloat(value);
      },
      symbol: () => {
        if (!this.skipInvalid.value()) {
          throw new ChacaError(`You can not export a Symbol into a sql file.`);
        }

        return null;
      },
      string(value) {
        if (value.length < 255) {
          return new SQLVarchar(value);
        } else {
          return new SQLText(value);
        }
      },
      regexp(value) {
        return new SQLText(String(value));
      },
      undefined() {
        return new SQLNull();
      },
      object: (value) => {
        if (current) {
          for (const [key, data] of Object.entries(value)) {
            const datatype = this.execute({
              route: route.create(key),
              current: null,
              parent: parent,
              value: data,
              nested: true,
            });

            if (datatype) {
              const columnName = new ColumnName(this.utils, key);

              const column = parent.addColumn(
                new SQLColumn({
                  autoGenerated: false,
                  isKey: this.fixer.isKey(parent._name, columnName),
                  isNull: this.fixer.isNull(parent._name, columnName),
                  name: columnName,
                  isUnique: this.fixer.isUnique(parent._name, columnName),
                }),
                false,
              );

              current.row.add(
                new RowColumn(parent, { column: column, value: datatype }),
              );
            }
          }
        } else {
          const tableName = new TableName(this.utils, route.clone());
          const objectTable = this.tables.search(tableName);

          const row = new SQLRow();
          objectTable.addRow(row);

          const serial = objectTable.addSerial(row, this.generateIds);

          for (const [key, data] of Object.entries(value)) {
            const datatype = this.execute({
              route: route.create(key),
              parent: objectTable,
              value: data,
              current: null,
              nested: true,
            });

            if (datatype) {
              const columnName = new ColumnName(this.utils, key);

              const column = objectTable.addColumn(
                new SQLColumn({
                  autoGenerated: false,
                  isKey: this.fixer.isKey(objectTable._name, columnName),
                  isNull: this.fixer.isNull(objectTable._name, columnName),
                  name: columnName,
                  isUnique: this.fixer.isUnique(objectTable._name, columnName),
                }),
                false,
              );

              row.add(
                new RowColumn(objectTable, { column: column, value: datatype }),
              );

              if (column.isKey()) {
                serial.setDisabled();
              }
            }
          }

          this.fillParentKeys.execute({
            nested: nested,
            parent: parent,
            row: row,
            table: objectTable,
          });

          if (row.hasKey(serial)) {
            serial.setDisabled();
          }

          if (!row.hasKey()) {
            throw new ChacaError(
              `The table ${objectTable.name()} must have at least 1 PRIMARY KEY`,
            );
          }
        }

        return null;
      },
      array: (value) => {
        const tableName = new TableName(this.utils, route.clone());
        const arrayTable = this.tables.add(
          new SQLTable(this.utils, tableName, true),
        );

        for (const v of value) {
          const row = new SQLRow();
          arrayTable.addRow(row);

          const serial = arrayTable.addSerial(row, this.generateIds);

          const datatype = this.execute({
            route: route.create("array"),
            parent: arrayTable,
            value: v,
            current: {
              row: row,
            },
            nested: true,
          });

          if (datatype) {
            const name = new ColumnName(this.utils, "value");

            const column = arrayTable.addColumn(
              new SQLColumn({
                name: name,
                autoGenerated: false,
                isKey: false,
                isNull: false,
                isUnique: false,
              }),
              false,
            );

            row.add(
              new RowColumn(arrayTable, { column: column, value: datatype }),
            );
          }

          this.fillParentKeys.execute({
            table: arrayTable,
            nested: nested,
            parent: parent,
            row: row,
          });

          if (row.hasKey(serial)) {
            serial.setDisabled();
          }

          if (!row.hasKey()) {
            throw new ChacaError(
              `The table ${arrayTable.name()} must have at least 1 PRIMARY KEY`,
            );
          }
        }

        return null;
      },
    });

    return type;
  }
}
