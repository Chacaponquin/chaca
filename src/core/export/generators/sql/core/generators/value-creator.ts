import { ChacaError } from "../../../../../../errors";
import { ChacaUtils } from "../../../../../utils";
import { Datatype } from "../../../../core/datatype";
import { SkipInvalid } from "../../../../core/skip-invalid";
import { GenerateIds } from "../../value-object/generate-ids";
import {
  SQLDatatype,
  SQLFloat,
  SQLInteger,
  SQLBigint,
  SQLBoolean,
  SQLDate,
  SQLNull,
  SQLText,
  SQLVarchar,
} from "../sql-types";
import { SQLColumn } from "../table/column";
import { SQLRow } from "../table/row";
import { RowColumn } from "../table/row-column";
import { SQLTable } from "../table/table";
import { SQLTables } from "../table/tables";
import { TablesFixer } from "./fixer";
import { ColumnName, TableName } from "./names";
import { Route } from "./route";

interface Props {
  parent: SQLTable;
  table: SQLTable | null;
  route: Route;
  value: any;
}

export class ValueCreator {
  constructor(
    private readonly utils: ChacaUtils,
    private readonly fixer: TablesFixer,
    private readonly tables: SQLTables,
    private readonly skipInvalid: SkipInvalid,
    private readonly generateIds: GenerateIds,
  ) {}

  execute({ route, parent, table, value }: Props): SQLDatatype[] {
    const type = Datatype.filter<SQLDatatype[]>(value, {
      int(value) {
        return [new SQLInteger(value)];
      },
      float(value) {
        return [new SQLFloat(value)];
      },
      bigint(value) {
        return [new SQLBigint(value)];
      },
      boolean(value) {
        return [new SQLBoolean(value)];
      },
      date(value) {
        return [new SQLDate(value)];
      },
      function: () => {
        if (this.skipInvalid.value()) {
          return [];
        }

        throw new ChacaError(`You can not export a function into a sql file.`);
      },
      null() {
        return [new SQLNull()];
      },
      nan(value) {
        return [new SQLFloat(value)];
      },
      symbol: () => {
        if (this.skipInvalid.value()) {
          return [];
        }

        throw new ChacaError(`You can not export a Symbol into a sql file.`);
      },
      string(value) {
        if (value.length < 255) {
          return [new SQLVarchar(value)];
        }

        return [new SQLText(value)];
      },
      regexp(value) {
        return [new SQLText(String(value))];
      },
      undefined() {
        return [new SQLNull()];
      },
      object: (value) => {
        const tableName = new TableName(this.utils, route);
        const objectTable = table ? table : this.tables.search(tableName);

        const row = new SQLRow();
        objectTable.addRow(row);

        for (const [key, data] of Object.entries(value)) {
          const datatypes = this.execute({
            route: route.create(key),
            parent: objectTable,
            table: null,
            value: data,
          });

          for (let i = 0; i < datatypes.length; i++) {
            const columnName = new ColumnName(this.utils, key, i);

            const column = objectTable.addColumn(
              new SQLColumn({
                datatype: datatypes[i],
                autoGenerated: false,
                isKey: this.fixer.isKey(objectTable._name, columnName),
                isNull: this.fixer.isNull(objectTable._name, columnName),
                name: columnName,
                isUnique: this.fixer.isUnique(objectTable._name, columnName),
              }),
              false,
            );

            const rowValue = new RowColumn({
              column: column,
              value: datatypes[i],
            });

            row.add(rowValue);
          }
        }

        objectTable.addSerial(row, this.generateIds.value(), row.hasKey());

        if (!row.hasKey()) {
          throw new ChacaError(
            `The table ${objectTable.name()} must have at least 1 PRIMARY KEY`,
          );
        }

        return [];
      },
      array: (value) => {
        const tableName = new TableName(this.utils, route.clone());
        const arrayTable = this.tables.add(
          new SQLTable(this.utils, tableName, true),
        );

        for (const v of value) {
          const row = new SQLRow();
          arrayTable.addRow(row);

          const datatypes = this.execute({
            route: route.create("array"),
            table: arrayTable,
            parent: arrayTable,
            value: v,
          });

          for (let i = 0; i < datatypes.length; i++) {
            const name = new ColumnName(this.utils, "value", i);
            const datatype = datatypes[i];

            const column = arrayTable.addColumn(
              new SQLColumn({
                datatype: datatype,
                name: name,
                autoGenerated: false,
                isKey: false,
                isNull: false,
                isUnique: false,
              }),
              false,
            );

            const rowValue = new RowColumn({ column: column, value: datatype });

            row.add(rowValue);
          }

          const parentKeys = parent.lastKeys();

          for (const key of parentKeys) {
            const keyName = new ColumnName(
              this.utils,
              `${parent.name()}_${key.column().name()}`,
              0,
            );

            const column = arrayTable.addColumn(
              new SQLColumn({
                isKey: false,
                isNull: false,
                name: keyName,
                datatype: key.refValue(),
                autoGenerated: false,
                isUnique: false,
              }),
              false,
            );

            column.setRef({ table: parent, column: key.column() });

            const rowValue = new RowColumn({
              column: column,
              value: key.value(),
            });

            row.add(rowValue);
          }

          arrayTable.addSerial(row, true, false);
        }

        return [];
      },
    });

    return type;
  }
}
